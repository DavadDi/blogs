<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. ACE_Select_Reactor_T 介绍 &mdash; sphinx_example 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="sphinx_example 0.1 documentation" href="index.html" />
    <link rel="next" title="3. I/O Handler的管理" href="Handler_mgr.html" />
    <link rel="prev" title="1. ACE学习综述" href="ACE_Intro.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>sphinx_example 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>2. ACE_Select_Reactor_T 介绍</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="ACE_Intro.html">1. ACE学习综述</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Handler_mgr.html">3. I/O Handler的管理</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="contents topic" id="id1">
<p class="topic-title first">本章目录</p>
<ul class="simple">
<li><a class="reference internal" href="#ace-select-reactor-t" id="id7">ACE_Select_Reactor_T 介绍</a><ul>
<li><a class="reference internal" href="#id2" id="id8">类继承图</a></li>
<li><a class="reference internal" href="#id3" id="id9">类协作图</a></li>
<li><a class="reference internal" href="#mem-def" id="id10">类主要成员变量</a></li>
<li><a class="reference internal" href="#id5" id="id11">事件处理函数调用图</a></li>
<li><a class="reference internal" href="#id6" id="id12">事件处理主流程</a><ul>
<li><a class="reference internal" href="#handle-events" id="id13">handle_events 函数流程</a></li>
<li><a class="reference internal" href="#handle-events-i" id="id14">handle_events_i 函数流程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="ace-select-reactor-t">
<h1><a class="toc-backref" href="#id7">2. ACE_Select_Reactor_T 介绍</a><a class="headerlink" href="#ace-select-reactor-t" title="Permalink to this headline">¶</a></h1>
<p>该类继承自类ACE_Select_Reactor_Impl，实现了对IO时间、信号量、定时器的分发处理，公共的函数需要ACE_Reactor_Token进行锁定。typedef ACE_Select_Reactor_T&lt;ACE_Select_Reactor_Token&gt; ACE_Select_Reactor定义了常用的ACE_Select_Reactor类，可以在程序中直接使用。</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id8">2.1. 类继承图</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<img alt="_images/a03594.png" class="align-center" src="_images/a03594.png" />
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">2.2. 类协作图</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<a class="reference internal image-reference" href="_images/a03595.png"><img alt="select reactor" src="_images/a03595.png" style="width: 1096.2px; height: 343.8px;" /></a>
<p class="rubric">ACE_Select_Reactor 核心交互图，表明了 ACE_Select_Reactor 针对 Socket/IO, 定时器，通知和信号量的整体数据结构。</p>
<a class="reference internal image-reference" href="_images/a03595_part.png"><img alt="select reactor part" class="align-center" src="_images/a03595_part.png" /></a>
</div>
<div class="section" id="mem-def">
<span id="id4"></span><h2><a class="toc-backref" href="#id10">2.3. 类主要成员变量</a><a class="headerlink" href="#mem-def" title="Permalink to this headline">¶</a></h2>
<p>ACE_Select_Reactor_Impl继承自 ACE_Reactor_Impl，在类ACE_Select_Reactor_Impl中定义了常用的成员变量：</p>
<p class="rubric">ace/Select_Reactor_Base.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c1">/// 提供&lt;ACE_HANDLE&gt;到&lt;ACE_Event_Handler *&gt;的映射</span>
  <span class="n">ACE_Select_Reactor_Handler_Repository</span> <span class="n">handler_rep_</span><span class="p">;</span>

  <span class="c1">/// 跟踪使用select函数返回的已触发的handle</span>
  <span class="n">ACE_Select_Reactor_Handle_Set</span> <span class="n">dispatch_set_</span><span class="p">;</span>

  <span class="c1">/// 跟踪要被select函数跟踪的句柄</span>
  <span class="n">ACE_Select_Reactor_Handle_Set</span> <span class="n">wait_set_</span><span class="p">;</span>

  <span class="c1">/// 跟踪当前被挂起的句柄</span>
  <span class="n">ACE_Select_Reactor_Handle_Set</span> <span class="n">suspend_set_</span><span class="p">;</span>

  <span class="c1">/// 跟踪我们感兴趣但不使用select函数触发的其他类型的各种句柄，例如 handle_*() 函数的返回值大于 0</span>
  <span class="n">ACE_Select_Reactor_Handle_Set</span> <span class="n">ready_set_</span><span class="p">;</span>

  <span class="c1">/// 定义时间轮队列指针，默认为：ACE_Timer_Heap</span>
  <span class="n">ACE_Timer_Queue</span> <span class="o">*</span><span class="n">timer_queue_</span><span class="p">;</span>

  <span class="c1">/// 处理信号量而不是用全局/静态的变量</span>
  <span class="n">ACE_Sig_Handler</span> <span class="o">*</span><span class="n">signal_handler_</span><span class="p">;</span>

  <span class="c1">/// 回调对象用于唤醒睡眠中的ACE_Select_Reactor，默认为ACE_Select_Reactor_Notify</span>
  <span class="n">ACE_Reactor_Notify</span> <span class="o">*</span><span class="n">notify_handler_</span><span class="p">;</span>

  <span class="c1">/// 跟踪是否需要我们自己负责删除时间队列标志</span>
  <span class="kt">bool</span> <span class="n">delete_timer_queue_</span><span class="p">;</span>

  <span class="c1">/// 跟踪是否需要我们自己删除信号句柄</span>
  <span class="kt">bool</span> <span class="n">delete_signal_handler_</span><span class="p">;</span>

  <span class="c1">/// 跟踪是否需要我们自己删除通知句柄</span>
  <span class="kt">bool</span> <span class="n">delete_notify_handler_</span><span class="p">;</span>

  <span class="c1">/// 是否进行初始化的标记</span>
  <span class="kt">bool</span> <span class="n">initialized_</span><span class="p">;</span>

  <span class="c1">/// 是否自动重启&lt;handle_events&gt;的事件循环，如果select被信号量中断</span>
  <span class="kt">bool</span> <span class="n">restart_</span><span class="p">;</span>

  <span class="c1">/// 表明ACE_Select_Reactor主线程在&lt;notify&gt;回调等待列表中的位置。如果等于-1表明在list的尾部，</span>
  <span class="c1">/// 0表明在队列首部，如果大于1表明队列等待队列需要处理的数目</span>
  <span class="kt">int</span> <span class="n">requeue_position_</span><span class="p">;</span>

  <span class="c1">/// 创建该类的的原始线程</span>
  <span class="n">ACE_thread_t</span> <span class="n">owner_</span><span class="p">;</span>

  <span class="c1">/// 如果为true表明state已经在ACE_Event_Handler派发过程中发生了变化。这用于确定我们是否</span>
  <span class="c1">/// 需要在&lt;Select_Reactor&gt;的&lt;wait_for_multiple_events&gt;循环中做做另外一次迭代</span>
  <span class="c1">/// ACE_Select_Reactor_Impl::clear_dispatch_mask (ACE_HANDLE handle,ACE_Reactor_Mask mask)中修改了</span>
  <span class="c1">/// dispatch_set_中的handle的mask，则会将该状态设置成true。</span>
  <span class="kt">bool</span> <span class="n">state_changed_</span><span class="p">;</span>

  <span class="c1">/// 如果为false，则reactor在事件分发过程中将不屏蔽信号量。这对于不注册任何信号量句柄的程序非常有用，</span>
  <span class="c1">/// 如果修改这个mask的值，可以减少内核层次锁的开销</span>
  <span class="kt">bool</span> <span class="n">mask_signals_</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">其中ACE_Select_Reactor_Handler_Repository handler_rep_的数据结构定义，可参见 <a class="reference internal" href="Handler_mgr.html#event-handlers-def"><em>bind 函数</em></a> 。</p>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id11">2.4. 事件处理函数调用图</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<a class="reference internal image-reference" href="_images/reactor_fun_call.png"><img alt="reactor_fun_call" src="_images/reactor_fun_call.png" /></a>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">calculate_timeout</span></tt> 函数的调用为类实现中 <tt class="docutils literal"><span class="pre">timer_queue_</span></tt> 时间队列中最早到期时间，以便设置后续 <tt class="docutils literal"><span class="pre">select</span></tt> 调用函数的超时时间，从而实现了时间队列与IO句柄触发的整合。</p>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id12">2.5. 事件处理主流程</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p class="rubric">ace/Reactor.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span>
<span class="n">ACE_Reactor</span><span class="o">::</span><span class="n">run_reactor_event_loop</span> <span class="p">(</span><span class="n">ACE_Time_Value</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span>
                                     <span class="n">REACTOR_EVENT_HOOK</span> <span class="n">eh</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ACE_TRACE</span> <span class="p">(</span><span class="s">&quot;ACE_Reactor::run_reactor_event_loop&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">reactor_event_loop_done</span> <span class="p">())</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">      <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">implementation_</span><span class="o">-&gt;</span><span class="n">handle_events</span> <span class="p">(</span><span class="n">tv</span><span class="p">);</span>
</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">eh</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">eh</span><span class="p">)</span> <span class="p">(</span><span class="k">this</span><span class="p">))</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">implementation_</span><span class="o">-&gt;</span><span class="n">deactivated</span> <span class="p">())</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// The &lt;handle_events&gt; method timed out without dispatching</span>
          <span class="c1">// anything.  Because of rounding and conversion errors and</span>
          <span class="c1">// such, it could be that the wait loop (WFMO, select, etc.)</span>
          <span class="c1">// timed out, but the timer queue said it wasn&#39;t quite ready</span>
          <span class="c1">// to expire a timer. In this case, the ACE_Time_Value we</span>
          <span class="c1">// passed into handle_events won&#39;t have quite been reduced</span>
          <span class="c1">// to 0, and we need to go around again. If we are all the</span>
          <span class="c1">// way to 0, just return, as the entire time the caller</span>
          <span class="c1">// wanted to wait has been used up.</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">usec</span> <span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="c1">// Else there were some events dispatched; go around again</span>
    <span class="p">}</span>

  <span class="n">ACE_NOTREACHED</span> <span class="p">(</span><span class="k">return</span> <span class="mi">0</span><span class="p">;)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>行12行，Reactor调用了其实现者的 <tt class="docutils literal"><span class="pre">handle_events(ACE_Time_Value</span> <span class="pre">*max_wait_time)</span></tt> 函数，实现类的handle_event函数承担了主要工作的分发和处理。</p>
<div class="section" id="handle-events">
<h3><a class="toc-backref" href="#id13">2.5.1. handle_events 函数流程</a><a class="headerlink" href="#handle-events" title="Permalink to this headline">¶</a></h3>
<p class="rubric">ace/Select_Reactor_T.cpp handle_events 函数</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;</span> <span class="kt">int</span>
<span class="n">ACE_Select_Reactor_T</span><span class="o">&lt;</span><span class="n">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;::</span><span class="n">handle_events</span>
  <span class="p">(</span><span class="n">ACE_Time_Value</span> <span class="o">*</span><span class="n">max_wait_time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ACE_TRACE</span> <span class="p">(</span><span class="s">&quot;ACE_Select_Reactor_T::handle_events&quot;</span><span class="p">);</span>

  <span class="c1">// Stash the current time -- the destructor of this object will</span>
  <span class="c1">// automatically compute how much time elapsed since this method was</span>
  <span class="c1">// called.</span>
  <span class="n">ACE_Countdown_Time</span> <span class="nf">countdown</span> <span class="p">(</span><span class="n">max_wait_time</span><span class="p">);</span>

<span class="cp">#if defined (ACE_MT_SAFE) &amp;&amp; (ACE_MT_SAFE != 0)</span>

  <span class="n">ACE_GUARD_RETURN</span> <span class="p">(</span><span class="n">ACE_SELECT_REACTOR_TOKEN</span><span class="p">,</span> <span class="n">ace_mon</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">token_</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="hll">  <span class="k">if</span> <span class="p">(</span><span class="n">ACE_OS</span><span class="o">::</span><span class="n">thr_equal</span> <span class="p">(</span><span class="n">ACE_Thread</span><span class="o">::</span><span class="n">self</span> <span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">owner_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span>    <span class="p">{</span>
      <span class="n">errno</span> <span class="o">=</span> <span class="n">EACCES</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">deactivated_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">errno</span> <span class="o">=</span> <span class="n">ESHUTDOWN</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="c1">// Update the countdown to reflect time waiting for the mutex.</span>
  <span class="n">countdown</span><span class="p">.</span><span class="n">update</span> <span class="p">();</span>
<span class="cp">#else</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">deactivated_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">errno</span> <span class="o">=</span> <span class="n">ESHUTDOWN</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ACE_MT_SAFE */</span><span class="cp"></span>

<span class="hll">  <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle_events_i</span> <span class="p">(</span><span class="n">max_wait_time</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="handle-events-i">
<h3><a class="toc-backref" href="#id14">2.5.2. handle_events_i 函数流程</a><a class="headerlink" href="#handle-events-i" title="Permalink to this headline">¶</a></h3>
<p class="rubric">ace/Select_Reactor_T.cpp handle_events_i 函数</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;</span> <span class="kt">int</span>
<span class="n">ACE_Select_Reactor_T</span><span class="o">&lt;</span><span class="n">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;::</span><span class="n">handle_events_i</span>
  <span class="p">(</span><span class="n">ACE_Time_Value</span> <span class="o">*</span><span class="n">max_wait_time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">ACE_SEH_TRY</span>
    <span class="p">{</span>
      <span class="c1">// We use the data member dispatch_set_ as the current dispatch</span>
      <span class="c1">// set.</span>

      <span class="c1">// We need to start from a clean dispatch_set</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_set_</span><span class="p">.</span><span class="n">rd_mask_</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_set_</span><span class="p">.</span><span class="n">wr_mask_</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_set_</span><span class="p">.</span><span class="n">ex_mask_</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>

      <span class="kt">int</span> <span class="n">number_of_active_handles</span> <span class="o">=</span>
<span class="hll">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_for_multiple_events</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_set_</span><span class="p">,</span>
</span><span class="hll">                                        <span class="n">max_wait_time</span><span class="p">);</span>
</span>
      <span class="n">result</span> <span class="o">=</span>
<span class="hll">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch</span> <span class="p">(</span><span class="n">number_of_active_handles</span><span class="p">,</span>
</span><span class="hll">                        <span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_set_</span><span class="p">);</span>
</span>    <span class="p">}</span>
  <span class="n">ACE_SEH_EXCEPT</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">release_token</span> <span class="p">())</span>
    <span class="p">{</span>
      <span class="c1">// As it stands now, we catch and then rethrow all Win32</span>
      <span class="c1">// structured exceptions so that we can make sure to release the</span>
      <span class="c1">// &lt;token_&gt; lock correctly.</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>行18, <tt class="docutils literal"><span class="pre">this-&gt;wait_for_multiple_events</span> <span class="pre">(this-&gt;dispatch_set_,max_wait_time)</span></tt> 实现了对于可分发句柄集的获取。</p>
<p>行21，<tt class="docutils literal"><span class="pre">this-&gt;dispatch</span> <span class="pre">(number_of_active_handles,this-&gt;dispatch_set_)</span></tt> 实现了对于分发句柄集的处理。</p>
<div class="section" id="wait-for-multiple-events">
<h4>2.5.2.1. wait_for_multiple_events 函数<a class="headerlink" href="#wait-for-multiple-events" title="Permalink to this headline">¶</a></h4>
<p class="rubric">ace/Select_Reactor_T.cpp wait_for_multiple_events 函数</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// Must be called with lock held.</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;</span> <span class="kt">int</span>
<span class="n">ACE_Select_Reactor_T</span><span class="o">&lt;</span><span class="n">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;::</span><span class="n">wait_for_multiple_events</span>
  <span class="p">(</span><span class="n">ACE_Select_Reactor_Handle_Set</span> <span class="o">&amp;</span><span class="n">dispatch_set</span><span class="p">,</span>
   <span class="n">ACE_Time_Value</span> <span class="o">*</span><span class="n">max_wait_time</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ACE_TRACE</span> <span class="p">(</span><span class="s">&quot;ACE_Select_Reactor_T::wait_for_multiple_events&quot;</span><span class="p">);</span>
  <span class="n">ACE_Time_Value</span> <span class="nf">timer_buf</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">ACE_Time_Value</span> <span class="o">*</span><span class="n">this_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="hll">  <span class="kt">int</span> <span class="n">number_of_active_handles</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">any_ready</span> <span class="p">(</span><span class="n">dispatch_set</span><span class="p">);</span>
</span>
  <span class="c1">// If there are any bits enabled in the &lt;ready_set_&gt; then we&#39;ll</span>
  <span class="c1">// handle those first, otherwise we&#39;ll block in &lt;select&gt;.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">number_of_active_handles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">do</span>
        <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">timer_queue_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

          <span class="n">this_timeout</span> <span class="o">=</span>
<span class="hll">            <span class="k">this</span><span class="o">-&gt;</span><span class="n">timer_queue_</span><span class="o">-&gt;</span><span class="n">calculate_timeout</span> <span class="p">(</span><span class="n">max_wait_time</span><span class="p">,</span>
</span><span class="hll">                                                   <span class="o">&amp;</span><span class="n">timer_buf</span><span class="p">);</span>
</span><span class="cp">#ifdef ACE_WIN32</span>
          <span class="c1">// This arg is ignored on Windows and causes pointer</span>
          <span class="c1">// truncation warnings on 64-bit compiles.</span>
          <span class="kt">int</span> <span class="k">const</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
          <span class="kt">int</span> <span class="k">const</span> <span class="n">width</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">handler_rep_</span><span class="p">.</span><span class="n">max_handlep1</span> <span class="p">();</span>
<span class="cp">#endif  </span><span class="cm">/* ACE_WIN32 */</span><span class="cp"></span>

          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">rd_mask_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_set_</span><span class="p">.</span><span class="n">rd_mask_</span><span class="p">;</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">wr_mask_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_set_</span><span class="p">.</span><span class="n">wr_mask_</span><span class="p">;</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">ex_mask_</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">wait_set_</span><span class="p">.</span><span class="n">ex_mask_</span><span class="p">;</span>
<span class="hll">          <span class="n">number_of_active_handles</span> <span class="o">=</span> <span class="n">ACE_OS</span><span class="o">::</span><span class="n">select</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span>
</span><span class="hll">                                                     <span class="n">dispatch_set</span><span class="p">.</span><span class="n">rd_mask_</span><span class="p">,</span>
</span><span class="hll">                                                     <span class="n">dispatch_set</span><span class="p">.</span><span class="n">wr_mask_</span><span class="p">,</span>
</span><span class="hll">                                                     <span class="n">dispatch_set</span><span class="p">.</span><span class="n">ex_mask_</span><span class="p">,</span>
</span><span class="hll">                                                     <span class="n">this_timeout</span><span class="p">);</span>
</span>        <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">number_of_active_handles</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">handle_error</span> <span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">number_of_active_handles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
<span class="cp">#if !defined (ACE_WIN32)</span>
          <span class="c1">// Resynchronize the fd_sets so their &quot;max&quot; is set properly.</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">rd_mask_</span><span class="p">.</span><span class="n">sync</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">handler_rep_</span><span class="p">.</span><span class="n">max_handlep1</span> <span class="p">());</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">wr_mask_</span><span class="p">.</span><span class="n">sync</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">handler_rep_</span><span class="p">.</span><span class="n">max_handlep1</span> <span class="p">());</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">ex_mask_</span><span class="p">.</span><span class="n">sync</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">handler_rep_</span><span class="p">.</span><span class="n">max_handlep1</span> <span class="p">());</span>
<span class="cp">#endif </span><span class="cm">/* ACE_WIN32 */</span><span class="cp"></span>
        <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">number_of_active_handles</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// Normally, select() will reset the bits in dispatch_set</span>
          <span class="c1">// so that only those filed descriptors that are ready will</span>
          <span class="c1">// have bits set.  However, when an error occurs, the bit</span>
          <span class="c1">// set remains as it was when the select call was first made.</span>
          <span class="c1">// Thus, we now have a dispatch_set that has every file</span>
          <span class="c1">// descriptor that was originally waited for, which is not</span>
          <span class="c1">// correct.  We must clear all the bit sets because we</span>
          <span class="c1">// have no idea if any of the file descriptors is ready.</span>
          <span class="c1">//</span>
          <span class="c1">// NOTE: We dont have a test case to reproduce this</span>
          <span class="c1">// problem. But pleae dont ignore this and remove it off.</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">rd_mask_</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">wr_mask_</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
          <span class="n">dispatch_set</span><span class="p">.</span><span class="n">ex_mask_</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

  <span class="c1">// Return the number of events to dispatch.</span>
  <span class="k">return</span> <span class="n">number_of_active_handles</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>行12,，<tt class="docutils literal"><span class="pre">this-&gt;any_ready(dispatch_set)</span></tt> 实现了获取不需要select函数触发的其他类型满足触发条件的句柄</p>
<p>行25-26，<tt class="docutils literal"><span class="pre">this-&gt;timer_queue_-&gt;calculate_timeout(max_wait_time,&amp;timer_buf)</span></tt> 实现了对定时器队列的超时的计算</p>
<p>行38-42，<tt class="docutils literal"><span class="pre">ACE_OS::select(width,dispatch_set.rd_mask_,dispatch_set.wr_mask_,dispatch_set.ex_mask_,this_timeout)</span></tt> 实现了对使用select函数返回的已触发的handle的跟踪</p>
</div>
<div class="section" id="dispatch">
<h4>2.5.2.2. dispatch 函数<a class="headerlink" href="#dispatch" title="Permalink to this headline">¶</a></h4>
<p class="rubric">ace/Select_Reactor_T.cpp dispatch 函数</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;</span> <span class="kt">int</span>
<span class="n">ACE_Select_Reactor_T</span><span class="o">&lt;</span><span class="n">ACE_SELECT_REACTOR_TOKEN</span><span class="o">&gt;::</span><span class="n">dispatch</span>
  <span class="p">(</span><span class="kt">int</span> <span class="n">active_handle_count</span><span class="p">,</span>
   <span class="n">ACE_Select_Reactor_Handle_Set</span> <span class="o">&amp;</span><span class="n">dispatch_set</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ACE_TRACE</span> <span class="p">(</span><span class="s">&quot;ACE_Select_Reactor_T::dispatch&quot;</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">io_handlers_dispatched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">other_handlers_dispatched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">signal_occurred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// The following do/while loop keeps dispatching as long as there</span>
  <span class="c1">// are still active handles.  Note that the only way we should ever</span>
  <span class="c1">// iterate more than once through this loop is if signals occur</span>
  <span class="c1">// while we&#39;re dispatching other handlers.</span>

  <span class="k">do</span>
    <span class="p">{</span>
      <span class="c1">// We expect that the loop will decrease the number of active</span>
      <span class="c1">// handles in each iteration.  If it does not, then something is</span>
      <span class="c1">// inconsistent in the state of the Reactor and we should avoid</span>
      <span class="c1">// the loop.  Please read the comments on bug 2540 for more</span>
      <span class="c1">// details.</span>
      <span class="kt">int</span> <span class="n">initial_handle_count</span> <span class="o">=</span> <span class="n">active_handle_count</span><span class="p">;</span>

      <span class="c1">// Note that we keep track of changes to our state.  If any of</span>
      <span class="c1">// the dispatch_*() methods below return -1 it means that the</span>
      <span class="c1">// &lt;wait_set_&gt; state has changed as the result of an</span>
      <span class="c1">// &lt;ACE_Event_Handler&gt; being dispatched.  This means that we</span>
      <span class="c1">// need to bail out and rerun the select() loop since our</span>
      <span class="c1">// existing notion of handles in &lt;dispatch_set&gt; may no longer be</span>
      <span class="c1">// correct.</span>
      <span class="c1">//</span>
      <span class="c1">// In the beginning, our state starts out unchanged.  After</span>
      <span class="c1">// every iteration (i.e., due to signals), our state starts out</span>
      <span class="c1">// unchanged again.</span>

      <span class="k">this</span><span class="o">-&gt;</span><span class="n">state_changed_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

      <span class="c1">// Perform the Template Method for dispatching all the handlers.</span>

      <span class="c1">// First check for interrupts.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">active_handle_count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// Bail out -- we got here since &lt;select&gt; was interrupted.</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ACE_Sig_Handler</span><span class="o">::</span><span class="n">sig_pending</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
              <span class="n">ACE_Sig_Handler</span><span class="o">::</span><span class="n">sig_pending</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

              <span class="c1">// If any HANDLES in the &lt;ready_set_&gt; are activated as a</span>
              <span class="c1">// result of signals they should be dispatched since</span>
              <span class="c1">// they may be time critical...</span>
<span class="hll">              <span class="n">active_handle_count</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">any_ready</span> <span class="p">(</span><span class="n">dispatch_set</span><span class="p">);</span>
</span>
              <span class="c1">// Record the fact that the Reactor has dispatched a</span>
              <span class="c1">// handle_signal() method.  We need this to return the</span>
              <span class="c1">// appropriate count below.</span>
              <span class="n">signal_occurred</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="k">else</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

      <span class="c1">// Handle timers early since they may have higher latency</span>
      <span class="c1">// constraints than I/O handlers.  Ideally, the order of</span>
      <span class="c1">// dispatching should be a strategy...</span>
<span class="hll">      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_timer_handlers</span> <span class="p">(</span><span class="n">other_handlers_dispatched</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span>        <span class="c1">// State has changed or timer queue has failed, exit loop.</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="c1">// Check to see if there are no more I/O handles left to</span>
      <span class="c1">// dispatch AFTER we&#39;ve handled the timers...</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">active_handle_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">io_handlers_dispatched</span>
          <span class="o">+</span> <span class="n">other_handlers_dispatched</span>
          <span class="o">+</span> <span class="n">signal_occurred</span><span class="p">;</span>

      <span class="c1">// Next dispatch the notification handlers (if there are any to</span>
      <span class="c1">// dispatch).  These are required to handle multi-threads that</span>
      <span class="c1">// are trying to update the &lt;Reactor&gt;.</span>

<span class="hll">      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_notification_handlers</span>
</span><span class="hll">               <span class="p">(</span><span class="n">dispatch_set</span><span class="p">,</span>
</span><span class="hll">                <span class="n">active_handle_count</span><span class="p">,</span>
</span><span class="hll">                <span class="n">other_handlers_dispatched</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span>        <span class="c1">// State has changed or a serious failure has occured, so exit</span>
        <span class="c1">// loop.</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="c1">// Finally, dispatch the I/O handlers.</span>
<span class="hll">      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">dispatch_io_handlers</span>
</span><span class="hll">               <span class="p">(</span><span class="n">dispatch_set</span><span class="p">,</span>
</span><span class="hll">                <span class="n">active_handle_count</span><span class="p">,</span>
</span><span class="hll">                <span class="n">io_handlers_dispatched</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span>        <span class="c1">// State has changed, so exit loop.</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="c1">// if state changed, we need to re-eval active_handle_count,</span>
      <span class="c1">// so we will not end with an endless loop</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">initial_handle_count</span> <span class="o">==</span> <span class="n">active_handle_count</span>
          <span class="o">||</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">state_changed_</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">active_handle_count</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">any_ready</span> <span class="p">(</span><span class="n">dispatch_set</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">active_handle_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">io_handlers_dispatched</span> <span class="o">+</span> <span class="n">other_handlers_dispatched</span> <span class="o">+</span> <span class="n">signal_occurred</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>处理顺序：</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">dispatch_timer_handlers</span></tt> 处理分发定时器，定时器的处理优于Socket/IO的处理。 展开流程见： <a class="reference internal" href="Timer_mgr.html#timer-reactor"><em>定时器与Select_Reactor的分发集成</em></a>。</li>
<li><tt class="docutils literal"><span class="pre">dispatch_notification_handlers</span></tt> 处理分发通知类消息。展开流程见： <a class="reference internal" href="Notification_mgr.html#notify-reactor"><em>通知与Select_Reactor 的分发集成</em></a>。</li>
<li><tt class="docutils literal"><span class="pre">dispatch_io_handlers</span></tt> 处理分发 io handlers。展开流程见： <a class="reference internal" href="Handler_mgr.html#handler-reactor"><em>IO句柄与Select_Reactor的分发集成</em></a>。</li>
</ol>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="ACE_Intro.html">1. ACE学习综述</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Handler_mgr.html">3. I/O Handler的管理</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2014, diweihua.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>